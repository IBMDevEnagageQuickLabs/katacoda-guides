## Deploying to Kubernetes

You’ve finished writing your code and want to deploy to Kubernetes. The Kabanero project integrates Tekton as a CI/CD pipeline for deploying to Kubernetes (including Knative and Istio). This enables you to commit your changes to a git repo and have a Tekton pipeline build and potentially deploy the project.

A full Kabanero set-up was considered too much for this workshop, so here we are going to make use of a nice little feature from Appsody, `appsody deploy`. In the terminal in the root of your project, type:

`appsody deploy`{{execute}}

<pre>
Built docker image dev.local/nodejs
Using applicationImage of: dev.local/nodejs
Attempting to apply resource in Kubernetes ...
Running command: kubectl apply -f app-deploy.yaml --namespace default
Deployment succeeded.
Appsody Deployment name is: nodejs
Running command: kubectl get rt nodejs -o jsonpath="{.status.url}" --namespace default
Attempting to get resource from Kubernetes ...
Running command: kubectl get route nodejs -o jsonpath={.status.ingress[0].host} --namespace default
Attempting to get resource from Kubernetes ...
Running command: kubectl get svc nodejs -o jsonpath=http://{.status.loadBalancer.ingress[0].hostname}:{.spec.ports[0].nodePort} --namespace default
Deployed project running at http://localhost:30062
</pre>

The very last line tells you where the application is available. Let’s call the resource by opening this endpoint in the browser:

Take note of the port number `http://localhost:<PORT_NUMBER>` `e.g: 30000` as you will need the port number to access the end point 

<a href="https://[[HOST_SUBDOMAIN]]-30000-[[KATACODA_HOST]].environments.katacoda.com/resource"> http://localhost:30000/resource</a>

Type in the port number into the katacoda webpage to access the end point.

You should now see the response from your JAX-RS resource.

Let’s take a look at the deployment. Enter:

`kubectl get all`{{execute}}

You should see an output similar to this:

<pre>
NAME                                    READY   STATUS    RESTARTS   AGE
pod/appsody-operator-6bbddbd455-r65vp   1/1     Running   0          6m57s
pod/nodejs-7d84ddc98d-r7bnj             1/1     Running   0          44s


NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
service/appsody-operator   ClusterIP   10.100.219.241   xxx.xxx       8383/TCP         6m51s
service/kubernetes         ClusterIP   10.96.0.1        xxx.xxx       443/TCP          9m13s
service/nodejs             NodePort    10.110.138.128   xxx.xxx       3000:30062/TCP   44s


NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/appsody-operator   1/1     1            1           6m57s
deployment.apps/nodejs             1/1     1            1           44s

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/appsody-operator-6bbddbd455   1         1         1       6m57s
replicaset.apps/nodejs-7d84ddc98d             1         1         1       44s
</pre>

The entries with `nodejs` are your applications. The `appsody-operator` are those used by Appsody to perform the deployment.

It’s worth noting at this point that this deployment was achieved without us having to write, or understand, a Dockerfile or Kubernetes deployment yaml.

Now list the files in your project directory. 

`ls -la`{{execute}}

You should see something like this:

<pre>

-rw-r--r--  1 nastacio  staff    628 Oct  8 14:05 app-deploy.yaml
-rw-r--r--  1 nastacio  staff    130 Oct  8 14:02 app.js
-rw-r--r--  1 nastacio  staff  51421 Oct  8 14:02 package-lock.json
-rw-r--r--  1 nastacio  staff    455 Oct  8 14:02 package.json
drwxr-xr-x  3 nastacio  staff     96 Oct  8 14:02 test

</pre>

The `app-deploy.yaml` is generated from the stack and used to deploy to Kubernetes. If you look inside the file, you’ll see entries for `liveness` and `readiness` probes, metrics, and the service port.

Check out the `liveness` and `readiness` endpoints by pointing your browser at the following URLs, remembering to replace the port numbers with the port numbers from the output of the `appsody deploy` command:

<a href="https://[[HOST_SUBDOMAIN]]-30000-[[KATACODA_HOST]].environments.katacoda.com/live"> http://localhost:30000/live</a>

<a href="https://[[HOST_SUBDOMAIN]]-30000-[[KATACODA_HOST]].environments.katacoda.com/ready"> http://localhost:30000/ready</a>

You should see something like:

<pre>
// http://localhost:30062/ready

{
    "status":"UP",
    "checks":[]
}
</pre>

These endpoints are provided by the stack health checks generated by the project starter.

Finally, let’s undeploy the application by entering:

`appsody deploy delete`{{execute}}

You should see an output something like this:

<pre>
....
Deleting deployment using deployment manifest app-deploy.yaml
Attempting to delete resource from Kubernetes...
Running command: kubectl delete -f app-deploy.yaml --namespace default
Deployment deleted
....
</pre>

Check that everything was undeployed using:

`kubectl get all`{{execute}}

Check that everything was undeployed using:

<pre>
NAME                                    READY   STATUS    RESTARTS   AGE
pod/appsody-operator-6bbddbd455-r65vp   1/1     Running   0          13m


NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/appsody-operator   ClusterIP   10.100.219.241                 8383/TCP   13m
service/kubernetes         ClusterIP   10.96.0.1                      443/TCP    15m


NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/appsody-operator   1/1     1            1           13m

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/appsody-operator-6bbddbd455   1         1         1       13m
</pre>

What if you decide you want to see the Container and Kubernetes configuration that Appsody is using, or you want to take your project elsewhere? You can do this as follows. Enter:

`appsody extract --target-dir tmp-extract`{{execute}}

You should see output similar to:

<pre>
Extracting project from development environment
Pulling docker image dev.local/nodejs-express:SNAPSHOT
Running command: docker pull dev.local/nodejs-express:SNAPSHOT
Error response from daemon: Get https://dev.local/v2/: Service Unavailable
[Warning] Docker image pull failed: exit status 1
Using local cache for image dev.local/nodejs-express:SNAPSHOT
[Warning] The stack image does not contain APPSODY_PROJECT_DIR. Using /project
Running command: docker create --name nodejs-extract -v /Users/nastacio/workspace/kabanero-workshop/nodejs/:/project/user-app dev.local/nodejs-express:SNAPSHOT
Running command: docker cp nodejs-extract:/project /Users/nastacio/.appsody/extract/nodejs
Running command: docker rm nodejs-extract -f
Project extracted to /Users/nastacio/workspace/kabanero-workshop/nodejs/tmp-extract
</pre>

Let’s take a look at the extracted project:

`cd ~/workspace/kabanero-workshop/nodejs/tmp-extract`{{execute}}

`ls -al`{{execute}}

These are the files for the project, including those provided by the stack. For example, the `package.json` has the core application definition for your application, and the `Dockerfile` is the one used to build and package the application. The `user-app` is the Node.js project for your application.

